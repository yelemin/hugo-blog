---
date: 2023-12-13
tags:
  - 计算机原理
title: 关于计算机中的原码,反码和补码
description: 
slug: 00:13
share: true
canonicalURL: ""
keywords:
  - 关键字1
  - 关键字2
series: 系列
filename: index
lastmod: 
lang: cn
image: 
author: 
dir: post/关于计算机中的原码,反码和补码
categories:
  - 计算机原理
weight: 1
---

写这个的主要原因是为了总结(主要是对于IDE来说):
首先计算机为了解决用原码或反码运算时所带来的不变,引入补码来进行计算机中的基本运算.

比如对于C语言中的一个int变量一般占4字节,也就是32bits,对应着计算机里面的01的位数,而在计算机中为了方便直接让数字按照补码形式存储,也就是说对于1来说在计算机中用00...001存储(0有31个),而-1则用1111..111(32个1)存储.

进一步,对于C语言中用十六进制表示数字时,普通的0xF就表示十进制下15,而对于特殊的0xFFFFFFFF(8个F)则表示-1,为什么呢?因为十六进制数的表示也是与字节相关的,一个0~F的十六进制数可以表示计算机中4位的bits,那么8位的十六进制数就可以表示32位的bits,也就是4字节,又因为int类型变量的32位的bits是由1位符号位和其他31位二进制数表示的,这就解释了为什么int类型最大值为21474836473,因为二进制下加上符号位01111...11(31个1)就表示这么大的数.但是要注意这32位是补码,也就是说当一个十六进制数有8位的时候,就可以表示计算机中存储int类型能表示的任意大小的数了.

比如0xFFFFFFFF表示的就是-1(十六进制代表的补码),而对于普通的0xF并没有达到**影响符号位**的长度,就依然是一个正常的数字.

学了位运算后(注意都是按位的),就有一个小知识点,对于一个大于等于0的数的补码还是原码本身,而对于负数来说,它的补码也可以用它的正数形式取反加一得到,也就是 -n=(~n)+1,这就在求lowbit的时候有点用处.

衍生出来就是一个数的取反加一就得到这个数的相反数了.
